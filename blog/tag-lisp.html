<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="alternate" type="application/rss+xml" href=
  "https://samarthkishor.github.io/blog/rss.xml" title=
  "RSS feed for https://samarthkishor.github.io/blog/">
  <title>Samarth's Blog</title>
  <meta name="author" content="Samarth Kishor">
  <meta name="referrer" content="no-referrer">
  <link href="static/style.css" rel="stylesheet" type="text/css">
</head>
<body>
  <div id="preamble" class="status">
    <header>
      <nav>
        <ul>
          <li>
            <a href="/">About</a>
          </li>
          <li>
            <a href="/blog/archive.html">Blog</a>
          </li>
        </ul>
      </nav>
    </header>
  </div>
  <div id="content">
    <h1 class="title">Posts tagged "lisp":</h1>
    <div class="post-date">
      11 Mar 2020
    </div>
    <h1 class="post-title"><a href=
    "https://samarthkishor.github.io/blog/fizzbuzz-approaches.html">
    Three Completely Different Approaches to the FizzBuzz
    Problem</a></h1>
    <p>Here’s a solution to the classic infamous FizzBuzz problem
    in Python:</p>
    <div class="org-src-container">
      <pre class="src src-python"><span style=
      "color: #80A0C2;">for</span> i <span style=
      "color: #80A0C2;">in</span> <span style=
      "color: #8EBCBB;">range</span>(<span style=
      "color: #B58DAE; font-weight: bold;">1</span>, <span style=
      "color: #B58DAE; font-weight: bold;">31</span>):
    <span style="color: #80A0C2;">if</span> i % <span style=
"color: #B58DAE; font-weight: bold;">15</span> == <span style=
"color: #B58DAE; font-weight: bold;">0</span>:
        <span style="color: #80A0C2;">print</span>(<span style=
"color: #A2BF8A;">"FizzBuzz"</span>)
    <span style="color: #80A0C2;">elif</span> i % <span style=
"color: #B58DAE; font-weight: bold;">3</span> == <span style=
"color: #B58DAE; font-weight: bold;">0</span>:
        <span style="color: #80A0C2;">print</span>(<span style=
"color: #A2BF8A;">"Fizz"</span>)
    <span style="color: #80A0C2;">elif</span> i % <span style=
"color: #B58DAE; font-weight: bold;">5</span> == <span style=
"color: #B58DAE; font-weight: bold;">0</span>:
        <span style="color: #80A0C2;">print</span>(<span style=
"color: #A2BF8A;">"Buzz"</span>)
    <span style="color: #80A0C2;">else</span>:
        <span style="color: #80A0C2;">print</span>(i)
</pre>
    </div>
    <pre class="example">
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
</pre>
    <p>This program is really simple and is probably the most
    common approach. You just need to understand how
    <code>if</code> statements work and you’re good to go.</p>
    <p>We can take this up a notch by using type-driven exhaustive
    pattern-matching so that our programming language can actually
    tell us if we’ve made a mistake in our implementation. Here’s
    version 2 of the FizzBuzz program using the OCaml programming
    language:</p>
    <div class="org-src-container">
      <pre class="src src-ocaml"><span style=
      "color: #f5deb3; font-weight: bold;">open </span><span style=
      "color: #ECCC87;">Base</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> () =
  <span style="color: #80A0C2;">for</span> i = <span style=
"color: #B58DAE; font-weight: bold;">1</span> <span style=
"color: #80A0C2;">to</span> <span style=
"color: #B58DAE; font-weight: bold;">30</span> <span style=
"color: #80A0C2;">do</span>
    <span style="color: #80A0C2;">match</span> <span style=
"color: #ECCC87;">Int.</span>rem i <span style=
"color: #B58DAE; font-weight: bold;">3</span>, <span style=
"color: #ECCC87;">Int.</span>rem i <span style=
"color: #B58DAE; font-weight: bold;">5</span> <span style=
"color: #80A0C2;">with</span>
    | <span style=
"color: #B58DAE; font-weight: bold;">0</span>, <span style=
"color: #B58DAE; font-weight: bold;">0</span> -&gt; <span style=
"color: #ECCC87;">Stdio.</span>print_endline <span style=
"color: #A2BF8A;">"FizzBuzz"</span>
    | <span style=
"color: #B58DAE; font-weight: bold;">0</span>, _ -&gt; <span style=
"color: #ECCC87;">Stdio.</span>print_endline <span style=
"color: #A2BF8A;">"Fizz"</span>
    | _, <span style=
"color: #B58DAE; font-weight: bold;">0</span> -&gt; <span style=
"color: #ECCC87;">Stdio.</span>print_endline <span style=
"color: #A2BF8A;">"Buzz"</span>
    | _, _ -&gt; <span style=
"color: #ECCC87;">Stdio.</span>printf <span style=
"color: #A2BF8A;">"%d\n"</span> i
  <span style="color: #80A0C2;">done</span>
</pre>
    </div>
    <pre class="example">
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
</pre>
    <p>Notice the <code>match</code> expression right after the
    <code>for</code> loop. OCaml has a really powerful type system
    that can catch some tricky edge cases in our logic at compile
    time. The function <code>Int.rem</code> is just like modulo in
    other languages (I’m using the <code>Base</code> alternate
    standard library for OCaml—the default language comes with a
    <code>mod</code> operator). All the <code>match</code>
    expression in the code above is doing is saying: “If i mod 3 is
    0 and i mod 5 is 0, then print FizzBuzz, else if i mod 3 is 0
    and i mod 5 is anything, then print Fizz, else if i mod 3 is
    anything and i mod 5 is 0, then print Buzz, else print i if
    both are anything”.</p>
    <p>That looks an awful lot like a standard <code>if</code>
    statement to me. The real advantage comes when you forget to
    include a case:</p>
    <div class="org-src-container">
      <pre class="src src-ocaml"><span style=
      "color: #f5deb3; font-weight: bold;">open </span><span style=
      "color: #ECCC87;">Base</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> () =
  <span style="color: #80A0C2;">for</span> i = <span style=
"color: #B58DAE; font-weight: bold;">1</span> <span style=
"color: #80A0C2;">to</span> <span style=
"color: #B58DAE; font-weight: bold;">30</span> <span style=
"color: #80A0C2;">do</span>
    <span style="color: #80A0C2;">match</span> <span style=
"color: #ECCC87;">Int.</span>rem i <span style=
"color: #B58DAE; font-weight: bold;">3</span>, <span style=
"color: #ECCC87;">Int.</span>rem i <span style=
"color: #B58DAE; font-weight: bold;">5</span> <span style=
"color: #80A0C2;">with</span>
    | <span style=
"color: #B58DAE; font-weight: bold;">0</span>, <span style=
"color: #B58DAE; font-weight: bold;">0</span> -&gt; <span style=
"color: #ECCC87;">Stdio.</span>print_endline <span style=
"color: #A2BF8A;">"FizzBuzz"</span>
    | <span style=
"color: #B58DAE; font-weight: bold;">0</span>, _ -&gt; <span style=
"color: #ECCC87;">Stdio.</span>print_endline <span style=
"color: #A2BF8A;">"Fizz"</span>
    | _, <span style=
"color: #B58DAE; font-weight: bold;">0</span> -&gt; <span style=
"color: #ECCC87;">Stdio.</span>print_endline <span style=
"color: #A2BF8A;">"Buzz"</span>
    <span style="color: #6f7787;">(* </span><span style=
"color: #6f7787;">| _, _ -&gt; Stdio.printf "%d\n" i &lt;-- commented out </span><span style="color: #6f7787;">*)</span>
  <span style="color: #80A0C2;">done</span>
</pre>
    </div>
    <pre class="example">
Characters 45-207:
  ....match Int.rem i 3, Int.rem i 5 with
      | 0, 0 -&gt; Stdio.print_endline "FizzBuzz"
      | 0, _ -&gt; Stdio.print_endline "Fizz"
      | _, 0 -&gt; Stdio.print_endline "Buzz"
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(1, 1)
Exception: Match_failure ("//toplevel//", 300, 4).
Raised at file "//toplevel//", line 303, characters 14-40
Called from file "toplevel/toploop.ml", line 180, characters 17-56
</pre>
    <p>This is really cool—OCaml’s compiler knows when the
    <code>match</code> statement doesn’t cover all the possible
    cases and will even give you an example of a case that wasn’t
    met! Once we include that last case, the program will
    successfully compile. Depending how you structure your pattern
    matching, the compiler will sometimes even tell you if you’ve
    used redundant or incorrect cases. It’s a killer feature and I
    wish more languages had it. Exhaustive pattern matching like
    this is usually unique to strongly typed functional programming
    languages, although Rust has also adopted this feature and I’m
    sure others will follow.</p>
    <p>Now for the third and wildest approach to solving the
    FizzBuzz problem—this time with Clojure. Clojure is a Lisp
    dialect that emphasizes functional programming and immutable
    data structures. This language also happens to have great
    support for lazy sequences—a feature that this particular
    FizzBuzz program uses heavily.</p>
    <p>A lazy sequence is not evaluated immediately—instead, it
    delays its evaluation until it is needed by another
    function.</p>
    <p>To illustrate this, here’s the documentation for the
    <code>cycle</code> function in Clojure:</p>
    <div class="org-src-container">
      <pre class="src src-clojure"><span style=
      "color: #80A0C2;">(</span>doc cycle<span style=
      "color: #80A0C2;">)</span>
</pre>
    </div>
    <pre class="example">
-------------------------
clojure.core/cycle
([coll])
  Returns a lazy (infinite!) sequence of repetitions of the items in coll.
</pre>
    <p>How do you use these so-called infinite sequences without
    using up all the memory in your computer? The key to using lazy
    sequences is that these functions are not evaluated until they
    are needed by another function. So running this:</p>
    <div class="org-src-container">
      <pre class="src src-clojure"><span style=
      "color: #80A0C2;">(</span>cycle '<span style=
      "color: #B58DAE;">(</span><span style=
      "color: #A2BF8A;">"Fizz"</span> <span style=
      "color: #A2BF8A;">"Buzz"</span><span style=
      "color: #B58DAE;">)</span><span style=
      "color: #80A0C2;">)</span>
</pre>
    </div>
    <p>would just hang the Clojure session because it’s waiting to
    be evaluated. Let’s fix that by taking some values from this
    infinite sequence.</p>
    <div class="org-src-container">
      <pre class="src src-clojure"><span style=
      "color: #80A0C2;">(</span>take <span style=
      "color: #B58DAE; font-weight: bold;">10</span> <span style=
      "color: #B58DAE;">(</span>cycle '<span style=
      "color: #A2BF8A;">(</span><span style=
      "color: #A2BF8A;">"Fizz"</span> <span style=
      "color: #A2BF8A;">"Buzz"</span><span style=
      "color: #A2BF8A;">)</span><span style=
      "color: #B58DAE;">)</span><span style=
      "color: #80A0C2;">)</span>
</pre>
    </div>
    <table>
      <colgroup>
        <col class="org-left">
        <col class="org-left">
        <col class="org-left">
        <col class="org-left">
        <col class="org-left">
        <col class="org-left">
        <col class="org-left">
        <col class="org-left">
        <col class="org-left">
        <col class="org-left">
      </colgroup>
      <tbody>
        <tr>
          <td class="org-left">Fizz</td>
          <td class="org-left">Buzz</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">Buzz</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">Buzz</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">Buzz</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">Buzz</td>
        </tr>
      </tbody>
    </table>
    <p>Now we can write a completely different FizzBuzz
    implementation leveraging the power of these lazy sequences. I
    modified the example from <a href=
    "http://www.petecorey.com/blog/2018/07/09/golfing-for-fizzbuzz-in-clojure-and-elixir/">
    this blog post</a> so the output would match my Python and
    OCaml programs.</p>
    <div class="org-src-container">
      <pre class="src src-clojure"><span style=
      "color: #80A0C2;">(</span><span style=
      "color: #80A0C2;">doseq</span>
    <span style="color: #B58DAE;">[</span>x
     <span style="color: #A2BF8A;">(</span><span style=
"color: #80A0C2;">-&gt;&gt;</span>
      <span style="color: #80A0C2;">(</span>map list
           <span style="color: #B58DAE;">(</span>range <span style=
"color: #B58DAE; font-weight: bold;">31</span><span style=
"color: #B58DAE;">)</span>
           <span style="color: #B58DAE;">(</span>cycle <span style=
"color: #A2BF8A;">[</span><span style=
"color: #A2BF8A;">"Fizz"</span> <span style=
"color: #A2BF8A;">""</span> <span style=
"color: #A2BF8A;">""</span><span style=
"color: #A2BF8A;">]</span><span style="color: #B58DAE;">)</span>
           <span style="color: #B58DAE;">(</span>cycle <span style=
"color: #A2BF8A;">[</span><span style=
"color: #A2BF8A;">"Buzz"</span> <span style=
"color: #A2BF8A;">""</span> <span style=
"color: #A2BF8A;">""</span> <span style=
"color: #A2BF8A;">""</span> <span style=
"color: #A2BF8A;">""</span><span style=
"color: #A2BF8A;">]</span><span style=
"color: #B58DAE;">)</span><span style="color: #80A0C2;">)</span>
      <span style="color: #80A0C2;">(</span>rest<span style=
"color: #80A0C2;">)</span>
      <span style="color: #80A0C2;">(</span>map <span style=
"color: #B58DAE;">(</span><span style=
"color: #80A0C2;">fn</span> <span style=
"color: #A2BF8A;">[</span>lst<span style="color: #A2BF8A;">]</span>
             <span style="color: #A2BF8A;">(</span><span style=
"color: #80A0C2;">let</span> <span style=
"color: #80A0C2;">[</span>i <span style=
"color: #B58DAE;">(</span>first lst<span style=
"color: #B58DAE;">)</span><span style="color: #80A0C2;">]</span>
               <span style="color: #80A0C2;">(</span><span style=
"color: #80A0C2;">if</span> <span style=
"color: #B58DAE;">(</span><span style=
"color: #80A0C2;">or</span> <span style=
"color: #A2BF8A;">(</span>= <span style=
"color: #B58DAE; font-weight: bold;">0</span> <span style=
"color: #80A0C2;">(</span>mod i <span style=
"color: #B58DAE; font-weight: bold;">3</span><span style=
"color: #80A0C2;">)</span><span style=
"color: #A2BF8A;">)</span> <span style=
"color: #A2BF8A;">(</span>= <span style=
"color: #B58DAE; font-weight: bold;">0</span> <span style=
"color: #80A0C2;">(</span>mod i <span style=
"color: #B58DAE; font-weight: bold;">5</span><span style=
"color: #80A0C2;">)</span><span style=
"color: #A2BF8A;">)</span><span style="color: #B58DAE;">)</span>
                 <span style=
"color: #B58DAE;">(</span>apply str <span style=
"color: #A2BF8A;">(</span>concat <span style=
"color: #80A0C2;">(</span>rest lst<span style=
"color: #80A0C2;">)</span><span style=
"color: #A2BF8A;">)</span><span style="color: #B58DAE;">)</span>
                 <span style=
"color: #B58DAE;">(</span>apply str <span style=
"color: #A2BF8A;">(</span>concat lst<span style=
"color: #A2BF8A;">)</span><span style=
"color: #B58DAE;">)</span><span style=
"color: #80A0C2;">)</span><span style=
"color: #A2BF8A;">)</span><span style=
"color: #B58DAE;">)</span><span style=
"color: #80A0C2;">)</span><span style=
"color: #A2BF8A;">)</span><span style="color: #B58DAE;">]</span>
  <span style="color: #B58DAE;">(</span>println x<span style=
"color: #B58DAE;">)</span><span style="color: #80A0C2;">)</span>
</pre>
    </div>
    <pre class="example">
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
</pre>
    <p>The four lines of code below is the heart of the program. It
    uses the <code>range</code> function to assign numbers to the
    first elements of the lists and then uses the two
    <code>cycle</code> functions to assign either the empty string,
    Fizz, or Buzz to the second and third elements of the list
    respectively. It’s a really neat declarative way of
    implementing FizzBuzz and my mind was completely blown when I
    understood what the program really does.</p>
    <div class="org-src-container">
      <pre class="src src-clojure"><span style=
      "color: #80A0C2;">(</span>map list
     <span style="color: #B58DAE;">(</span>range <span style=
"color: #B58DAE; font-weight: bold;">31</span><span style=
"color: #B58DAE;">)</span>
     <span style="color: #B58DAE;">(</span>cycle <span style=
"color: #A2BF8A;">[</span><span style=
"color: #A2BF8A;">"Fizz"</span> <span style=
"color: #A2BF8A;">""</span> <span style=
"color: #A2BF8A;">""</span><span style=
"color: #A2BF8A;">]</span><span style="color: #B58DAE;">)</span>
     <span style="color: #B58DAE;">(</span>cycle <span style=
"color: #A2BF8A;">[</span><span style=
"color: #A2BF8A;">"Buzz"</span> <span style=
"color: #A2BF8A;">""</span> <span style=
"color: #A2BF8A;">""</span> <span style=
"color: #A2BF8A;">""</span> <span style=
"color: #A2BF8A;">""</span><span style=
"color: #A2BF8A;">]</span><span style=
"color: #B58DAE;">)</span><span style="color: #80A0C2;">)</span>
</pre>
    </div>
    <table>
      <colgroup>
        <col class="org-right">
        <col class="org-left">
        <col class="org-left">
      </colgroup>
      <tbody>
        <tr>
          <td class="org-right">0</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">Buzz</td>
        </tr>
        <tr>
          <td class="org-right">1</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">2</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">3</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">4</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">5</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">Buzz</td>
        </tr>
        <tr>
          <td class="org-right">6</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">7</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">8</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">9</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">10</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">Buzz</td>
        </tr>
        <tr>
          <td class="org-right">11</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">12</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">13</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">14</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">15</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">Buzz</td>
        </tr>
        <tr>
          <td class="org-right">16</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">17</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">18</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">19</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">20</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">Buzz</td>
        </tr>
        <tr>
          <td class="org-right">21</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">22</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">23</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">24</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">25</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">Buzz</td>
        </tr>
        <tr>
          <td class="org-right">26</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">27</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">28</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">29</td>
          <td class="org-left">&nbsp;</td>
          <td class="org-left">&nbsp;</td>
        </tr>
        <tr>
          <td class="org-right">30</td>
          <td class="org-left">Fizz</td>
          <td class="org-left">Buzz</td>
        </tr>
      </tbody>
    </table>
    <p>I never knew FizzBuzz could be solved in so many different
    ways and it’s a neat little problem to illustrate the strengths
    and styles of different programming languages: Python is great
    for writing legible imperative code that’s simple yet
    expressive. OCaml is great for writing safe strongly typed code
    with exhaustive compiler checks when you need them. Clojure is
    great for writing highly dynamic functional code which uses
    lots of abstractions that makes working with data much
    easier.</p>
    <div class="taglist">
      <a href=
      "https://samarthkishor.github.io/blog/tags.html">Tags</a>:
      <a href=
      "https://samarthkishor.github.io/blog/tag-programming.html">programming</a>
      <a href=
      "https://samarthkishor.github.io/blog/tag-python.html">python</a>
      <a href=
      "https://samarthkishor.github.io/blog/tag-ocaml.html">ocaml</a>
      <a href=
      "https://samarthkishor.github.io/blog/tag-lisp.html">lisp</a>
    </div>
    <div class="post-date">
      09 Mar 2020
    </div>
    <h1 class="post-title"><a href=
    "https://samarthkishor.github.io/blog/process-hacking.html">Remote
    Linux Process Hacking through SSH</a></h1>
    <p>There’s this really cool <a href=
    "https://www.youtube.com/playlist?list=PLBgJcoaU2hl-JnoVOzjYB5qk_PfYjPm-I">
    process hacking series</a> on YouTube by Keist Zenon. He uses
    the programming language Common Lisp to interact with processes
    on his Linux machine. I tried following the tutorial on my Mac,
    but macOS does not have the same <code>ptrace</code> commands
    and system call interfaces as Linux so this did not work out.
    However, I have VirtualBox set up on my Mac with a Debian VM
    which I use whenever I need Linux.</p>
    <p>Here’s the idea: is it possible to hack processes on my
    Linux VM from Emacs on my Mac? I found out that it’s not only
    possible, but it’s actually surprisingly easy.</p>
    <div id="outline-container-org5d0097d" class="outline-2">
      <h2 id="org5d0097d">Configuring the Virtual Machine</h2>
      <div class="outline-text-2" id="text-org5d0097d">
        <p>First you’ll need to set up a Bridged Adapter on your
        VirtualBox VM to allow your host machine to connect to it
        via SSH. <a href=
        "https://www.youtube.com/watch?v=ErzhbUusgdI">This YouTube
        tutorial</a> was pretty helpful. You’ll just have to change
        how you enable the SSH service on your Linux VM—I’m on
        Debian so I had to run the command</p>
        <div class="org-src-container">
          <pre class="src src-sh">
          systemctl status ssh | <span style=
"color: #ECCC87;">cat</span> | <span style=
"color: #ECCC87;">grep</span> active
</pre>
        </div>
        <pre class="example">
Active: active (running) since Fri 2020-03-13 18:24:14 EDT; 9min ago
</pre>
        <p>to see if SSH was enabled.</p>
        <p>To attach and manipulate this process, we need to use
        the <code>ptrace</code> function. You can see the
        documentation for it with the command <code>man 2
        ptrace</code> (2 stands for the second section of the
        manual, since we want the C system call function for
        <code>ptrace</code> instead of the general UNIX command).
        We could use C for process hacking, but it’s a lot nicer to
        use an interactive language like Lisp. Plus, it’s possible
        to interact with a remote Lisp REPL from your host
        machine’s local Emacs instance through SSH. Common Lisp is
        pretty amazing—I don’t know if many other programming
        languages have these features.</p>
        <p>Clone <a href=
        "https://github.com/k-stz/cl-ptrace">Keist’s GitHub
        repo</a> to your VM to get his Common Lisp library for
        process hacking with <code>ptrace</code>. The code here is
        essentially the same as the tutorial, except you might have
        to remove the line that says</p>
        <div class="org-src-container">
          <pre class="src src-common-lisp"><span style=
          "color: #80A0C2;">(</span><span style=
          "color: #8EBCBB;">:file</span> <span style=
          "color: #A2BF8A;">"cl-ptrace/async-functions"</span><span style=
          "color: #80A0C2;">)</span>
</pre>
        </div>
        <p>since that file doesn’t exist in the repo for some
        reason. Install your Common Lisp implementation of choice
        (I use <code>sbcl</code> since it’s well-supported on most
        platforms) and follow the instructions on the <a href=
        "https://www.quicklisp.org/beta/">Quicklisp website</a> to
        install Quicklisp. Quicklisp is the unofficial package
        manager for Common Lisp.</p>
        <p>Once you’ve successfully installed Quicklisp, you need
        to set up a Lisp REPL on the remote VM so it can talk to
        your local Emacs editor. Quit out of your <code>sbcl</code>
        repl and run it as root. We need Lisp to run as root since
        the <code>ptrace</code> system calls need root access.</p>
        <div class="org-src-container">
          <pre class="src src-sh"><span style=
          "color: #ECCC87;">sudo</span> sbcl
</pre>
        </div>
        <p>In his tutorial, Kaiste avoided this problem by running
        Emacs as root since he was hacking processes from the same
        machine. However, we don’t want to do this since running
        Emacs as root can be dangerous, plus we are trying to hack
        processes on our <i>remote</i> machine from our <i>local
        (host)</i> Emacs editor, so running Emacs locally as root
        wouldn’t really be useful.</p>
        <p>Use Quicklisp to load/install <code>ASDF</code> and
        <code>slynk</code>, and then create a <code>slynk</code>
        server on port 4006. You can use the default port 4005 if
        it’s open.</p>
        <div class="org-src-container">
          <pre class="src src-common-lisp"><span style=
          "color: #80A0C2;">(</span>ql:quickload <span style=
          "color: #8EBCBB;">:asdf</span><span style=
          "color: #80A0C2;">)</span>
<span style="color: #80A0C2;">(</span>ql:quickload <span style=
"color: #8EBCBB;">:slynk</span><span style=
"color: #80A0C2;">)</span>
<span style=
"color: #80A0C2;">(</span>slynk:create-server <span style=
"color: #8EBCBB;">:port</span> <span style=
"color: #B58DAE; font-weight: bold;">4006</span><span style=
"color: #80A0C2;">)</span>
</pre>
        </div>
        <p>If you get stuck, follow the instructions in <a href=
        "https://joaotavora.github.io/sly/#Setting-up-the-Lisp-image">
        the SLY manual</a>, but I think Quicklisp makes this
        process a bit easier.</p>
        <p>Now fire up a new terminal and get your VM’s ip address.
        On Debian, the command is</p>
        <div class="org-src-container">
          <pre class="src src-sh">hostname -I
</pre>
        </div>
        <p>After that, SSH into your VM from your <i>host</i>
        machine to create an SSH tunnel that we’ll take advantage
        of later.</p>
        <div class="org-src-container">
          <pre class="src src-sh">
          ssh -L4006:localhost:4006 &lt;username&gt;@&lt;ip-address&gt;
</pre>
        </div>
        <p>Change <code>4006</code> to the port that
        <code>slynk</code> is using to run your Lisp server, and
        change the <code>&lt;username&gt;</code> and
        <code>&lt;ip-address&gt;</code> fields. Remember to run
        this command from your host machine, not the VM.</p>
        <p>Once your SSH tunnel is set up, follow the instructions
        in section 8.1.3 of the SLY manual (linked above) to
        configure Emacs to translate filenames between the remote
        and host machines. Make sure you have TRAMP installed and
        working in Emacs. Now you can connect to your VM from your
        host machine’s Emacs using TRAMP. <code>C-x C-f
        /ssh:&lt;username&gt;@&lt;ip-address&gt;</code> should do
        the trick. Now you can navigate to the
        <code>cl-ptrace</code> repo.</p>
        <p>The setup is pretty much over: now we can start hacking.
        Compile the <code>spam.c</code> file in the
        <code>cl-ptrace</code> repo on your VM into the executable
        <code>spam</code> and run it.</p>
        <div class="org-src-container">
          <pre class="src src-sh">gcc spam.c -o spam
./spam
</pre>
        </div>
        <p>We want to get the process id (<code>pid</code>) of this
        <code>spam</code> program so we can interact with it. To do
        this, run the command</p>
        <div class="org-src-container">
          <pre class="src src-sh" id="org0d18523">
          ps -a | <span style=
"color: #ECCC87;">grep</span> spam | awk <span style=
"color: #A2BF8A;">'{ print $1 }'</span>
</pre>
        </div>
        <pre class="example">
1543
</pre>
        <p>We can then display information about the process with
        <code>top</code>. You can get a nicer output by using the
        <code>htop</code> program.</p>
        <div class="org-src-container">
          <pre class="src src-sh">top -p $<span style=
          "color: #dac6d6;">PID</span>
</pre>
        </div>
        <p>We can even limit the output of <code>top</code> to just
        get the CPU usage. The <code>sed</code> commands are just
        for making the output nicer.</p>
        <div class="org-src-container">
          <pre class="src src-sh">top -p $<span style=
          "color: #dac6d6;">PID</span> -n <span style=
          "color: #B58DAE; font-weight: bold;">2</span> -b | <span style=
          "color: #ECCC87;">grep</span> Cpu | sed <span style=
          "color: #A2BF8A;">'s/\:/\: /'</span> | sed <span style=
          "color: #A2BF8A;">'s/us,.*/ /'</span>
</pre>
        </div>
        <table>
          <colgroup>
            <col class="org-left">
            <col class="org-right">
          </colgroup>
          <tbody>
            <tr>
              <td class="org-left">%Cpu(s):</td>
              <td class="org-right">68.7</td>
            </tr>
            <tr>
              <td class="org-left">%Cpu(s):</td>
              <td class="org-right">99.7</td>
            </tr>
          </tbody>
        </table>
        <p>Notice that the <code>spam</code> program is taking up
        over 90% of the CPU since it’s an infinite
        <code>while</code> loop in a single-threaded process.</p>
      </div>
    </div>
    <div id="outline-container-org01037b7" class="outline-2">
      <h2 id="org01037b7">Hacking in Emacs</h2>
      <div class="outline-text-2" id="text-org01037b7">
        <p>Next, switch back to Emacs (on the host machine) and
        make sure you’re in the remote <code>cl-ptrace</code> repo
        via TRAMP. We want to connect to the remote Lisp server
        from Emacs, so run the command <code>M-x
        sly-connect</code>, keep the default host as
        <code>localhost</code>, and change the port to the
        <code>slynk</code> server port.</p>
        <p>Now you have a local Lisp REPL that is connected to your
        VM via the SSH tunnel we created earlier. Load the file
        <code>cl-ptrace.asd</code> with the command <code>M-x
        sly-load-file</code>. The file is on the remote VM, but
        this isn’t a problem because TRAMP should be configured to
        handle the remote filenames (we did this earlier). This
        should load the file into the <code>sly</code> REPL. Then
        run <code>(asdf:load-system "cl-ptrace")</code> to load the
        <code>cl-ptrace</code> library into the REPL, and run
        <code>(in-package :cl-ptrace)</code> to start using the
        library.</p>
        <p>Make sure that you’re root by running the function
        <code>(am-i-root?)</code>. It should return <code>T</code>.
        Now you’ve successfully created a mechanism to hack remote
        processes from your local machine using Common Lisp and
        Emacs. Go ahead and follow along with the rest of Kaiste’s
        videos—they’re amazing.</p>
      </div>
    </div>
    <div class="taglist">
      <a href=
      "https://samarthkishor.github.io/blog/tags.html">Tags</a>:
      <a href=
      "https://samarthkishor.github.io/blog/tag-programming.html">programming</a>
      <a href=
      "https://samarthkishor.github.io/blog/tag-lisp.html">lisp</a>
      <a href=
      "https://samarthkishor.github.io/blog/tag-linux.html">linux</a>
    </div>
    <div id="archive">
      <a href=
      "https://samarthkishor.github.io/blog/archive.html">Other
      posts</a>
    </div>
  </div>
</body>
</html>
