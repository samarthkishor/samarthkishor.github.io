<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="alternate" type="application/rss+xml" href=
  "https://samarthkishor.github.io/blog/rss.xml" title=
  "RSS feed for https://samarthkishor.github.io/blog/">
  <title>Remote Linux Process Hacking through SSH</title>
  <meta name="author" content="Samarth Kishor">
  <meta name="referrer" content="no-referrer">
  <link href="static/style.css" rel="stylesheet" type="text/css">
</head>
<body>
  <div id="preamble" class="status">
    <header>
      <nav>
        <ul>
          <li>
            <a href="/">About</a>
          </li>
          <li>
            <a href="/blog/">Blog</a>
          </li>
        </ul>
      </nav>
    </header>
  </div>
  <div id="content">
    <div class="post-date">
      09 Mar 2020
    </div>
    <h1 class="post-title"><a href=
    "https://samarthkishor.github.io/blog/process-hacking.html">Remote
    Linux Process Hacking through SSH</a></h1>
    <p>There’s this really cool <a href=
    "https://www.youtube.com/playlist?list=PLBgJcoaU2hl-JnoVOzjYB5qk_PfYjPm-I">
    process hacking series</a> on YouTube by Keist Zenon. He uses
    the programming language Common Lisp to interact with processes
    on his Linux machine. I tried following the tutorial on my Mac,
    but macOS does not have the same <code>ptrace</code> commands
    and system call interfaces as Linux so this did not work out.
    However, I have VirtualBox set up on my Mac with a Debian VM
    which I use whenever I need Linux.</p>
    <p>Here’s the idea: is it possible to hack processes on my
    Linux VM from Emacs on my Mac? I found out that it’s not only
    possible, but it’s actually surprisingly easy.</p>
    <p>First you’ll need to set up a Bridged Adapter on your
    VirtualBox VM to allow your host machine to connect to it via
    SSH. <a href="https://www.youtube.com/watch?v=ErzhbUusgdI">This
    YouTube tutorial</a> was pretty helpful. You’ll just have to
    change how you enable the SSH service on your Linux VM—I’m on
    Debian so I had to run the command</p>
    <div class="org-src-container">
      <pre class="src src-sh">systemctl status ssh
</pre>
    </div>
    <p>to see if SSH was enabled.</p>
    <p>To attach and manipulate this process, we need to use the
    <code>ptrace</code> function. You can see the documentation for
    it with the command <code>man 2 ptrace</code> (2 stands for the
    second section of the manual, since we want the C system call
    function for <code>ptrace</code> instead of the general UNIX
    command). We could use C for process hacking, but it’s a lot
    nicer to use an interactive language like Lisp. Plus, it’s
    possible to interact with a remote Lisp REPL from your host
    machine’s local Emacs instance through SSH. Common Lisp is
    pretty amazing—I don’t know if many other programming languages
    have these features.</p>
    <p>Clone <a href="https://github.com/k-stz/cl-ptrace">Keist’s
    GitHub repo</a> to your VM to get his Common Lisp library for
    process hacking with <code>ptrace</code>. The code here is
    essentially the same as the tutorial, except you might have to
    remove the line that says</p>
    <div class="org-src-container">
      <pre class="src src-common-lisp"><span style=
      "color: #80A0C2;">(</span><span style=
      "color: #8EBCBB;">:file</span> <span style=
      "color: #A2BF8A;">"cl-ptrace/async-functions"</span><span style=
      "color: #80A0C2;">)</span>
</pre>
    </div>
    <p>since that file doesn’t exist in the repo for some reason.
    Install your Common Lisp implementation of choice (I use
    <code>sbcl</code> since it’s well-supported on most platforms)
    and follow the instructions on the <a href=
    "https://www.quicklisp.org/beta/">Quicklisp website</a> to
    install Quicklisp. Quicklisp is the unofficial package manager
    for Common Lisp.</p>
    <p>Once you’ve successfully installed Quicklisp, you need to
    set up a Lisp REPL on the remote VM so it can talk to your
    local Emacs editor. Quit out of your <code>sbcl</code> repl and
    run it as root. We need Lisp to run as root since the
    <code>ptrace</code> system calls need root access.</p>
    <div class="org-src-container">
      <pre class="src src-sh"><span style=
      "color: #ECCC87;">sudo</span> sbcl
</pre>
    </div>
    <p>In his tutorial, Kaiste avoided this problem by running
    Emacs as root since he was hacking processes from the same
    machine. However, we don’t want to do this since running Emacs
    as root can be dangerous, plus we are trying to hack processes
    on our <i>remote</i> machine from our <i>local (host)</i> Emacs
    editor, so running Emacs locally as root wouldn’t really be
    useful.</p>
    <p>Use Quicklisp to load/install <code>ASDF</code> and
    <code>slynk</code>, and then create a <code>slynk</code> server
    on port 4006. You can use the default port 4005 if it’s
    open.</p>
    <div class="org-src-container">
      <pre class="src src-common-lisp"><span style=
      "color: #80A0C2;">(</span>ql:quickload <span style=
      "color: #8EBCBB;">:asdf</span><span style=
      "color: #80A0C2;">)</span>
<span style="color: #80A0C2;">(</span>ql:quickload <span style=
"color: #8EBCBB;">:slynk</span><span style=
"color: #80A0C2;">)</span>
<span style=
"color: #80A0C2;">(</span>slynk:create-server <span style=
"color: #8EBCBB;">:port</span> <span style=
"color: #B58DAE; font-weight: bold;">4006</span><span style=
"color: #80A0C2;">)</span>
</pre>
    </div>
    <p>If you get stuck, follow the instructions in <a href=
    "https://joaotavora.github.io/sly/#Setting-up-the-Lisp-image">the
    SLY manual</a>, but I think Quicklisp makes this process a bit
    easier.</p>
    <p>Now fire up a new terminal and get your VM’s ip address. On
    Debian, the command is</p>
    <div class="org-src-container">
      <pre class="src src-sh">ip a
</pre>
    </div>
    <p>After that, SSH into your VM from your <i>host</i> machine
    to create an SSH tunnel that we’ll take advantage of later.</p>
    <div class="org-src-container">
      <pre class="src src-sh">
      ssh -L4006:localhost:4006 &lt;username&gt;@&lt;ip-address&gt;
</pre>
    </div>
    <p>Change <code>4006</code> to the port that <code>slynk</code>
    is using to run your Lisp server, and change the
    <code>&lt;username&gt;</code> and
    <code>&lt;ip-address&gt;</code> fields. Remember to run this
    command from your host machine, not the VM.</p>
    <p>Once your SSH tunnel is set up, follow the instructions in
    section 8.1.3 of the SLY manual (linked above) to configure
    Emacs to translate filenames between the remote and host
    machines. Make sure you have TRAMP installed and working in
    Emacs. Now you can connect to your VM from your host machine’s
    Emacs using TRAMP. <code>C-x C-f
    /ssh:&lt;username&gt;@&lt;ip-address&gt;</code> should do the
    trick. Now you can navigate to the <code>cl-ptrace</code>
    repo.</p>
    <p>The setup is pretty much over: now we can start hacking.
    Compile the <code>spam.c</code> file in the
    <code>cl-ptrace</code> repo on your VM into the executable
    <code>spam</code> and run it.</p>
    <div class="org-src-container">
      <pre class="src src-sh">gcc spam.c -o spam
./spam
</pre>
    </div>
    <p>We want to get the process id (<code>pid</code>) of this
    <code>spam</code> program so we can interact with it. To do
    this, run the command</p>
    <div class="org-src-container">
      <pre class="src src-sh">ps -a | <span style=
      "color: #ECCC87;">grep</span> spam | awk <span style=
      "color: #A2BF8A;">'{ print $1 }'</span>
</pre>
    </div>
    <p>We can then display information about the process with
    <code>top</code>.</p>
    <div class="org-src-container">
      <pre class="src src-sh">top -p &lt;pid&gt;
</pre>
    </div>
    <p>Notice that the <code>spam</code> program is taking up over
    90% of the CPU since it’s an infinite <code>while</code> loop
    in a single-threaded process. You can get a nicer output by
    using the <code>htop</code> program.</p>
    <p>Next, switch back to Emacs (on the host machine) and make
    sure you’re in the <code>cl-ptrace</code> repo. We want to
    connect to the remote Lisp server from Emacs, so run the
    command <code>M-x sly-connect</code> keep the default host as
    <code>localhost</code> and change the port to the
    <code>slynk</code> server port. Now you have a local Lisp REPL
    that is connected to your VM via the SSH tunnel we created
    earlier. Load the file <code>cl-ptrace.asd</code> with the
    command <code>M-x sly-load-file</code>. The file is on the
    remote VM, but this isn’t a problem because TRAMP should be
    configured to handle the remote filenames (we did this
    earlier). This should load the file into the <code>sly</code>
    REPL. Then run <code>(asdf:load-system "cl-ptrace")</code> to
    load the <code>cl-ptrace</code> library into the REPL, and run
    <code>(in-package :cl-ptrace)</code> to start using the
    library.</p>
    <p>Make sure that you’re root by running the function
    <code>(am-i-root?)</code>. It should return <code>T</code>. Now
    you’ve successfully created a mechanism to hack remote
    processes from your local machine using Common Lisp and Emacs.
    Go ahead and follow along with the rest of Kaiste’s
    videos—they’re amazing.</p>
    <div class="taglist">
      <a href=
      "https://samarthkishor.github.io/blog/tags.html">Tags</a>:
      <a href=
      "https://samarthkishor.github.io/blog/tag-programming.html">programming</a>
      <a href=
      "https://samarthkishor.github.io/blog/tag-lisp.html">lisp</a>
      <a href=
      "https://samarthkishor.github.io/blog/tag-linux.html">linux</a>
    </div>
  </div>
  <div id="postamble" class="status"></div>
</body>
</html>
